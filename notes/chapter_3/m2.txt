                    Aggregate Functions

Aggregate functions are functions that take a collection (a set or multiset) of values as
input and return a single value. SQL offers five standard built-in aggregate functions:9
            • Average: avg
            • Minimum: min
            • Maximum: max
            • Total: sum
            • Count: count
The input to sum and avg must be a collection of numbers, but the other operators can
operate on collections of nonnumeric data types, such as strings, as well.

                Basic Aggregation
Consider the query 
“Find the average salary of instructors in the Computer Science department.” 
We write this query as follows:
        select avg (salary)
        from instructor
        where dept name = 'Comp. Sci.';
The result of this query is a relation with a single attribute containing a single tuple with
a numerical value corresponding to the average salary of instructors in the Computer
Science department. 

The database system may give an awkward name to the result
relation attribute that is generated by aggregation, consisting of the text of the expression; 
however, we can give a meaningful name to the attribute by using the as clause as
follows:
          select avg (salary) as avg salary
          from instructor
          where dept name = 'Comp. Sci.';

In the instructor relation of Figure 2.1, the salaries in the Computer Science department 
are $75,000, $65,000, and $92,000. The average salary is $232,000∕3 =
$77,333.33.

Retaining duplicates is important in computing an average. Suppose the Computer
Science department adds a fourth instructor whose salary happens to be $75,000. 
If duplicates were eliminated, we would obtain the wrong answer ($232,000∕4 = $58,000)
rather than the correct answer of $76,750.

There are cases where we must eliminate duplicates before computing an aggregate function. 
If we do want to eliminate duplicates, we use the keyword distinct in the
aggregate expression. 
An example arises in the query “Find the total number of instructors who teach a course in the Spring 2018 semester.” 
In this case, an instructor counts
only once, regardless of the number of course sections that the instructor teaches. The
required information is contained in the relation teaches, and we write this query as
follows:
              select count (distinct ID)
              from teaches
              where semester = 'Spring' and year = 2018;

Because of the keyword distinct preceding ID, even if an instructor teaches more than
one course, she is counted only once in the result.

We use the aggregate function count frequently to count the number of tuples in a
relation. The notation for this function in SQL is count (*). Thus, to find the number
of tuples in the course relation, we write
              select count (*)
              from course;

SQL does not allow the use of distinct with count (*). 

It is legal to use distinct with
max and min, even though the result does not change. We can use the keyword all in
place of distinct to specify duplicate retention, but since all is the default, there is no
need to do so.


                 Aggregation with Grouping
There are circumstances where we would like to apply the aggregate function not only
to a single set of tuples, but also to a group of sets of tuples; we specify this in SQL
using the group by clause. The attribute or attributes given in the group by clause are
used to form groups. Tuples with the same value on all attributes in the group by clause
are placed in one group.

As an illustration, consider the query 
    “Find the average salary in each department.”
We write this query as follows:
          select dept name, avg (salary) as avg salary
          from instructor
          group by dept name;

Figure shows the tuples in the instructor relation grouped by the dept name
attribute, which is the first step in computing the query result. 
    The specified aggregate
is computed for each group, and the result of the query is shown in Figure.


In contrast, consider the query “Find the average salary of all instructors.” 
We write this query as follows:
          select avg (salary)
          from instructor;
In this case the group by clause has been omitted, so the entire relation is treated as a
single group.


As another example of aggregation on groups of tuples, consider the query 
“Find the number of instructors in each department who teach a course in the Spring 2018
semester.” 
Information about which instructors teach which course sections in which
semester is available in the teaches relation. However, this information has to be joined
with information from the instructor relation to get the department name of each instructor. 
Thus, we write this query as follows:
          select dept name, count (distinct ID) as instr count
          from instructor, teaches
          where instructor.ID= teaches.ID and
          semester = 'Spring' and year = 2018
          group by dept name;


When an SQL query uses grouping, it is important to ensure that the only attributes
that appear in the select statement without being aggregated are those that are present
in the group by clause. In other words, any attribute that is not present in the group by
clause may appear in the select clause only as an argument to an aggregate function,
otherwise the query is treated as erroneous. 
For example, the following query is erroneous since ID does not appear in the group by clause, and yet it appears in the select
clause without being aggregated:
          /* erroneous query */
          select dept name, ID, avg (salary)
          from instructor
          group by dept name;

In the preceding query, each instructor in a particular group (defined by dept name)
can have a different ID, and since only one tuple is output for each group, there is no
unique way of choosing which ID value to output. As a result, such cases are disallowed
by SQL.
The preceding query also illustrates a comment written in SQL by enclosing text
in “/* */”; the same comment could have also been written as “–– erroneous query”.


                The Having Clause
At times, it is useful to state a condition that applies to groups rather than to tuples. 

For example, we might be interested in only those departments where the average salary of
the instructors is more than $42,000. 
            This condition does not apply to a single tuple;
rather, it applies to each group constructed by the group by clause. To express such
a query, we use the having clause of SQL. SQL applies predicates in the having clause
after groups have been formed, so aggregate functions may be used in the having clause.
We express this query in SQL as follows:
          select dept name, avg (salary) as avg salary
          from instructor
          group by dept name
          having avg (salary) > 42000;

As was the case for the select clause, any attribute that is present in the having
clause without being aggregated must appear in the group by clause, otherwise the
query is erroneous.
The meaning of a query containing aggregation, group by, or having clauses is defined by the following sequence of operations:

        1. As was the case for queries without aggregation, the from clause is first evaluated
        to get a relation.
        2. If a where clause is present, the predicate in the where clause is applied on the
        result relation of the from clause.
        3. Tuples satisfying the where predicate are then placed into groups by the group
        by clause if it is present. If the group by clause is absent, the entire set of tuples
        satisfying the where predicate is treated as being in one group.
        4. The having clause, if it is present, is applied to each group; the groups that do not
        satisfy the having clause predicate are removed.
        5. The select clause uses the remaining groups to generate tuples of the result of the
        query, applying the aggregate functions to get a single result tuple for each group.


To illustrate the use of both a having clause and a where clause in the same query,
we consider the query “For each course section offered in 2017, find the average total
credits (tot cred) of all students enrolled in the section, if the section has at least 2
students.”
            select course id, semester, year, sec id, avg (tot cred)
            from student, takes
            where student.ID= takes.ID and year = 2017
            group by course id, semester, year, sec id
            having count (ID) >= 2;
Note that all the required information for the preceding query is available from the
relations takes and student, and that although the query pertains to sections, a join
with section is not needed.


                      Aggregation with Null and Boolean Values
Null values, when they exist, complicate the processing of aggregate operators. 

For example, assume that some tuples in the instructor relation have a null value for salary.
Consider the following query to total all salary amounts:
    select sum (salary)
    from instructor;
The values to be summed in the preceding query include null values, since we assumed
that some tuples have a null value for salary. 
Rather than say that the overall sum is
itself null, 
            the SQL standard says that the sum operator should ignore null values in its input.


In general, aggregate functions treat nulls according to the following rule: 
          All aggregate functions except count (*) ignore null values in their input collection. 
          
As a result of null values being ignored, the collection of values may be empty. 
The count of an empty collection is defined to be 0, and all other aggregate operations return a value
of null when applied on an empty collection. The effect of null values on some of the
more complicated SQL constructs can be subtle.

A Boolean data type that can take values true, false, and unknown was introduced
in SQL:1999. 

The aggregate functions some and every can be applied on a collection of
Boolean values, and compute the disjunction (or) and conjunction (and), respectively,
of the values.



              Nested Subqueries
SQL provides a mechanism for nesting subqueries. A subquery is a select-from-where
expression that is nested within another query. A common use of subqueries is to perform tests for
set membership, make set comparisons, and determine set cardinality
by nesting subqueries in the where clause.


              Set Membership
SQL allows testing tuples for membership in a relation. The in connective tests for set
membership, where the set is a collection of values produced by a select clause. The
not in connective tests for the absence of set membership.

As an illustration, reconsider the query 
“Find all the courses taught in the both the Fall 2017 and Spring 2018 semesters.” 
Earlier, we wrote such a query by intersecting
two sets: 
  the set of courses taught in Fall 2017 and the set of courses taught in Spring
  2018. 

We can take the alternative approach of finding all courses that were taught in
Fall 2017 and that are also members of the set of courses taught in Spring 2018. 

This formulation generates the same results as the previous one did, but it leads us to write
our query using the in connective of SQL. We begin by finding all courses taught in
Spring 2018, and we write the subquery:
        (select course id
        from section  
        where semester = 'Spring' and year= 2018)
        
We then need to find those courses that were taught in the Fall 2017 and that appear
in the set of courses obtained in the subquery. 
We do so by nesting the subquery in the
where clause of an outer query. 
The resulting query is:
      select distinct course id
      from section
      where semester = 'Fall' and year= 2017 and
      course id in (select course id
      from section
      where semester = 'Spring' and year= 2018);


Note that we need to use distinct here because the intersect operation removes duplicates by default.
This example shows that it is possible to write the same query several ways in SQL.
This flexibility is beneficial, since it allows a user to think about the query in the way
that seems most natural. We shall see that there is a substantial amount of redundancy
in SQL.

We use the "not in" construct in a way similar to the in construct. 

For example, to find all the courses taught in the Fall 2017 semester but not in the Spring 2018 semester,
which we expressed earlier using the except operation, we can write:
          select distinct course id
          from section
          where semester = 'Fall' and year= 2017 and
          course id not in (select course id
          from section
          where semester = 'Spring' and year= 2018);
          
The "in" and "not in" operators can also be used on enumerated sets. The following
query selects the names of instructors whose names are neither “Mozart” nor “Einstein”.
          select distinct name
          from instructor
          where name not in ('Mozart', 'Einstein');

In the preceding examples, we tested membership in a one-attribute relation. 

It is also possible to test for membership in an arbitrary relation in SQL. 
For example, we can write the query 
    “find the total number of (distinct) students who have taken course sections taught by the instructor 
    with ID 110011” as follows:
    
      select count (distinct ID)
      from takes
      where (course id, sec id, semester, year) in (select course id, sec id, semester, year
      from teaches
      where teaches.ID= '10101');
Note, however, that some SQL implementations do not support the row construction syntax “(course id, sec id, semester, year)” used above. 
We will see alternative ways of writing this query.



            Set Comparison
As an example of the ability of a nested subquery to compare sets, consider the query
“Find the names of all instructors whose salary is greater than at least one instructor
in the Biology department.” In Section 3.4.1, we wrote this query as follows:

          select distinct T.name
          from instructor as T, instructor as S
          where T.salary > S.salary and S.dept name = 'Biology';
          
SQL does, however, offer an alternative style for writing the preceding query. The phrase
“greater than at least one” is represented in SQL by "> some". This construct allows us
to rewrite the query in a form that resembles closely our formulation of the query in
English.

          select name
          from instructor
          where salary > some (select salary
          from instructor
          where dept name = 'Biology');

The subquery:
      (select salary
      from instructor
      where dept name = 'Biology')
      
generates the set of all salary values of all instructors in the Biology department. The >
some comparison in the where clause of the outer select is true if the salary value of the
tuple is greater than at least one member of the set of all salary values for instructors
in Biology.

SQL also allows < some, <= some, >= some, = some, and <> some comparisons.
As an exercise, verify that = some is identical to in, whereas <> some is not the same
as not in.

Now we modify our query slightly. Let us find the names of all instructors that
have a salary value greater than that of each instructor in the Biology department. The
construct > all corresponds to the phrase “greater than all.” Using this construct, we
write the query as follows:
      select name
      from instructor
      where salary > all (select salary
              from instructor
              where dept name = 'Biology');

As it does forsome, SQL also allows < all, <= all, >= all, = all, and <> all comparisons.

As an exercise, verify that <> all is identical to not in, whereas = all is not the same as
in.

As another example of set comparisons, consider the query “Find the departments
that have the highest average salary.” We begin by writing a query to find all average
salaries, and then nest it as a subquery of a larger query that finds those departments
for which the average salary is greater than or equal to all average salaries:
          select dept name
          from instructor
          group by dept name
          having avg (salary) >= all (select avg (salary)
                              from instructor
                              group by dept name);



              Test for Empty Relations
SQL includes a feature for testing whether a subquery has any tuples in its result. 

The exists construct returns the value true if the argument subquery is nonempty. Using the
exists construct, we can write the query “Find all courses taught in both the Fall 2017
semester and in the Spring 2018 semester” in still another way:
          
          select course id
          from section as S
          where semester = 'Fall' and year= 2017 and
          exists (select *
              from section as T
              where semester = 'Spring' and year= 2018 and
              S.course id= T.course id);


The above query also illustrates a feature of SQL where a correlation name from
an outer query (S in the above query), can be used in a subquery in the where clause.
A subquery that uses a correlation name from an outer query is called a correlated
subquery.

In queries that contain subqueries, a scoping rule applies for correlation names.
In a subquery, according to the rule, it is legal to use only correlation names defined
in the subquery itself or in any query that contains the subquery. If a correlation name
is defined both locally in a subquery and globally in a containing query, the local definition applies. 
This rule is analogous to the usual scoping rules used for variables in
programming languages.


We can test for the nonexistence of tuples in a subquery by using the not exists
construct. We can use the not exists construct to simulate the set containment (that
is, superset) operation: We can write “relation A contains relation B” as “not exists (B
except A).” (Although it is not part of the current SQL standards, the contains operator was present 
in some early relational systems.) To illustrate the not exists operator,
consider the query 
    “Find all students who have taken all courses offered in the Biology department.” 
  
Using the except construct, we can write the query as follows:
          
          select S.ID, S.name
          from student as S
          where not exists ((select course id
                  from course
                  where dept name = 'Biology')
                  except
                  (select T.course id
                  from takes as T
                  where S.ID = T.ID));

Here, the subquery:
          (select course id
          from course
          where dept name = 'Biology')
finds the set of all courses offered in the Biology department. 

The subquery:
          (select T.course id
          from takes as T
          where S.ID = T.ID)

finds all the courses that student S.ID has taken. 
Thus, the outer select takes each student and tests whether the set of all courses that the student has taken contains the set
of all courses offered in the Biology department.

We saw in Section 3.8.1, an SQL query to 
  “find the total number of (distinct) students who have taken course sections taught by the instructor with ID 110011”. 
  
That query used a tuple constructor syntax that is not supported by some databases. An
alternative way to write the query, using the exists construct, is as follows:
            
            select count (distinct ID)
            from takes
            where exists (select course id, sec id, semester, year
                  from teaches
                  where teaches.ID= '10101'
                  and takes.course id = teaches.course id
                  and takes.sec id = teaches.sec id
                  and takes.semester = teaches.semester
                  and takes.year = teaches.year
                  );



          Test for the Absence of Duplicate Tuples
SQL includes a Boolean function for testing whether a subquery has duplicate tuples
in its result. 

The unique construct11 returns the value true if the argument subquery
contains no duplicate tuples. 

Using the unique construct, 
      we can write the query “Find
all courses that were offered at most once in 2017” as follows:
    
    select T.course id
    from course as T
    where unique (select R.course id
        from section as R
        where T.course id= R.course id and
        R.year = 2017);

Note that if a course were not offered in 2017, the subquery would return an empty
result, and the unique predicate would evaluate to true on the empty set.
An equivalent version of this query not using the unique construct is:
          
          select T.course id
          from course as T
          where 1 >= (select count(R.course id)
                from section as R
                where T.course id= R.course id and
                R.year = 2017);

We can test for the existence of duplicate tuples in a subquery by using the not
unique construct. To illustrate this construct, consider the query “Find all courses that
were offered at least twice in 2017” as follows:

          select T.course id
          from course as T
          where not unique (select R.course id
              from section as R
              where T.course id= R.course id and
              R.year = 2017);

Formally, the unique test on a relation is defined to fail if and only if the relation
contains two distinct tuples t1 and t2 such that t1 = t2. Since the test t1 = t2 fails if
any of the fields of t1 or t2 are null, it is possible for unique to be true even if there are
multiple copies of a tuple, as long as at least one of the attributes of the tuple is null.


                    Subqueries in the From Clause
SQL allows a subquery expression to be used in the from clause. The key concept applied here is that any select-from-where expression returns a relation as a result and,
therefore, can be inserted into another select-from-where anywhere that a relation can
appear.

Consider the query “Find the average instructors’ salaries of those departments
where the average salary is greater than $42,000.” We wrote this query in Section 3.7
by using the having clause. 
We can now rewrite this query, without using the having
clause, by using a subquery in the from clause, as follows:

        select dept name, avg salary
        from (select dept name, avg (salary) as avg salary
            from instructor
            group by dept name)
        where avg salary > 42000;

The subquery generates a relation consisting of the names of all departments and their
corresponding average instructors’ salaries. The attributes of the subquery result can
be used in the outer query, as can be seen in the above example.

Note that we do not need to use the having clause, since the subquery in the from
clause computes the average salary, and the predicate that was in the having clause
earlier is now in the where clause of the outer query.

We can give the subquery result relation a name, and rename the attributes, using
the as clause, as illustrated below.

We can give the subquery result relation a name, and rename the attributes, using
the as clause, as illustrated below.
          
          select dept name, avg salary
          from (select dept name, avg (salary)
          from instructor
          group by dept name)
          as dept avg (dept name, avg salary)
          where avg salary > 42000;

The subquery result relation is named dept avg, with the attributes dept name and avg
salary.

Nested subqueries in the from clause are supported by most but not all SQL implementations. Note that some SQL implementations, notably MySQL and PostgreSQL,
require that each subquery relation in the from clause must be given a name, even if the
name is never referenced; Oracle allows a subquery result relation to be given a name
(with the keyword as omitted) but does not allow renaming of attributes of the relation.

An easy workaround for that is to do the attribute renaming in the select clause of the
subquery; in the above query, the select clause of the subquery would be replaced by
            
        select dept name, avg(salary) as avg salary

      and
                “as dept_avg (dept name, avg salary)”
      would be replaced by
                “as dept_avg”

As another example, suppose we wish to find the maximum across all departments
of the total of all instructors’ salaries in each department. The having clause does not
help us in this task, but we can write this query easily by using a subquery in the from
clause, as follows:
          
          select max (tot salary)
          from (select dept name, sum(salary)
              from instructor
              group by dept name) as dept total (dept name, tot salary);

We note that nested subqueries in the from clause cannot use correlation variables
from other relations in the same from clause. However, the SQL standard, starting with
SQL:2003, allows a subquery in the from clause that is prefixed by the lateral keyword
to access attributes of preceding tables or subqueries in the same from clause. 

For example, if we wish to print the names of each instructor, along with their salary and
the average salary in their department, we could write the query as follows:
          
        select name, salary, avg salary
          from instructor I1, lateral (select avg(salary) as avg salary
                    from instructor I2
                    where I2.dept name= I1.dept name);

Without the lateral clause, the subquery cannot access the correlation variable I1 from
the outer query. Only the more recent implementations of SQL support the lateral
clause.



            The With Clause

The with clause provides a way of defining a temporary relation whose definition is
available only to the query in which the with clause occurs. 

Consider the following query, which finds those departments with the maximum budget.
              
              with max_budget(value) as
                    (select max(budget)
                    from department)
              select budget
              from department, max budget
              where department.budget = max budget.value;

The with clause in the query defines the temporary relation max_budget containing the
results of the subquery defining the relation. 

We could have written the preceding query by using a nested subquery in either the
from clause or the where clause. 
However, using nested subqueries would have made
the query harder to read and understand. The with clause makes the query logic clearer;
it also permits this temporary relation to be used in multiple places within a query.

For example, suppose we want to find all departments where the total salary is
greater than the average of the total salary at all departments. 
We can write the query using the with clause as follows:

          with dept total (dept name, value) as
                (select dept name, sum(salary)
                from instructor
                group by dept name),
          dept total avg(value) as
                (select avg(value)
                from dept total)
          select dept name
          from dept total, dept total avg
          where dept total.value > dept total avg.value;

We can create an equivalent query without the with clause, but it would be 
more complicated and harder to understand. You can write the equivalent query as an exercise.



              Scalar Subqueries
SQL allows subqueries to occur wherever an expression returning a value is permitted,
provided the subquery returns only one tuple containing a single attribute; such subqueries are called scalar subqueries. 

For example, a subquery can be used in the select clause as illustrated in the following example 
that lists all departments along with the number of instructors in each department:

              select dept name,
                    (select count(*)
                    from instructor
                    where department.dept name = instructor.dept name)
                    as num instructors
              from department;

The subquery in this example is guaranteed to return only a single value since it has
a count(*) aggregate without a group by. The example also illustrates the usage of 
correlation variables, that is, attributes of relations in the from clause of the outer query,
such as department.dept name in the above example.

Scalar subqueries can occur in select, where, and having clauses. Scalar subqueries
may also be defined without aggregates. It is not always possible to figure out at compile
time if a subquery can return more than one tuple in its result; if the result has more
than one tuple when the subquery is executed, a run-time error occurs.

Note that technically the type of a scalar subquery result is still a relation, even if
it contains a single tuple. However, when a scalar subquery is used in an expression
where a value is expected, SQL implicitly extracts the value from the single attribute of
the single tuple in the relation and returns that value.


          Scalar Without a From Clause
Certain queries require a calculation but no reference to any relation. Similarly, certain
queries may have subqueries that contain a from clause without the top-level query
needing a from clause.

As an example, suppose we wish to find the average number of sections taught (regardless of year or semester) per instructor, 
with sections taught by multiple instructors
counted once per instructor. We need to count the number of tuples in teaches to find
the total number of sections taught and count the number of tuples in instructor to find
the number of instructors. Then a simple division gives us the desired result. One might
write this as:
            
            (select count (*) from teaches)/(select count (*) from instructor)
            from dual;

While this is legal in some systems, others will report an error due to the lack of a
from clause. In the latter case, a special dummy relation called, for example, dual can
be created, containing a single tuple. This allows the preceding query to be written as:
select (select count (*) from teaches)/(select count (*) from instructor)
from dual;
Oracle provides a predefined relation called dual, containing a single tuple, for uses
such as the above (the relation has a single attribute, which is not relevant for our
purposes); you can create an equivalent relation if you use any other database.
Since the above queries divide one integer by another, the result would, on most
databases, be an integer, which would result in loss of precision. If you wish to get the
result as a floating point number, you could multiply one of the two subquery results by
1.0 to convert it to a floating point number, before the division operation is performed.





                  Modification of the Database

                      Deletion
A delete request is expressed in much the same way as a query. 
We can delete only whole tuples; we cannot delete values on only particular attributes. 

SQL expresses a deletion by:
        
        delete from r
        where P;

where P represents a predicate and r represents a relation. 

The delete statement first finds all tuples t in r for which P(t) is true, and then deletes them from r. 

The where clause can be omitted, in which case all tuples in r are deleted.

Note that a delete command operates on only one relation. If we want to delete
tuples from several relations, we must use one delete command for each relation. 

The predicate in the where clause may be as complex as a select command’s where clause.

At the other extreme, the where clause may be empty. The request:
                
              delete from instructor;

deletes all tuples from the instructor relation. The instructor relation itself still exists,
but it is empty.


Here are examples of SQL delete requests:

Delete all tuples in the instructor relation pertaining to instructors in the Finance
department.
              
              delete from instructor
              where dept name = 'Finance';

Delete all instructors with a salary between $13,000 and $15,000.
                  
                  delete from instructor
                  where salary between 13000 and 15000;


Delete all tuples in the instructor relation for those instructors associated with a
department located in the Watson building.
                
                delete from instructor
                where dept name in (select dept name
                from department
                where building = 'Watson');

This delete request first finds all departments located in Watson and then deletes
all instructor tuples pertaining to those departments.

Note that, although we may delete tuples from only one relation at a time, we may
reference any number of relations in a select-from-where nested in the where clause of a
delete. 

The delete request can contain a nested select that references the relation from
which tuples are to be deleted. 
For example, suppose that we want to delete the records
of all instructors with salary below the average at the university. We could write:
 
            delete from instructor
            where salary < (select avg (salary)
            from instructor);

The delete statement first tests each tuple in the relation instructor to check whether
the salary is less than the average salary of instructors in the university. Then, all tuples
that pass the test—that is, represent an instructor with a lower-than-average salary—are
deleted. 

Performing all the tests before performing any deletion is important—if some
tuples are deleted before other tuples have been tested, the average salary may change,
and the final result of the delete would depend on the order in which the tuples were
processed!



                                      Insertion
To insert data into a relation, we either specify a tuple to be inserted or write a query
whose result is a set of tuples to be inserted. The attribute values for inserted tuples
must be members of the corresponding attribute’s domain. Similarly, tuples inserted
must have the correct number of attributes.

The simplest insert statement is a request to insert one tuple. Suppose that we wish
to insert the fact that there is a course CS-437 in the Computer Science department
with title “Database Systems” and four credit hours. We write:

              insert into course
              values ('CS-437', 'Database Systems', 'Comp. Sci.', 4);


In this example, the values are specified in the order in which the corresponding attributes are listed in the relation schema. 

For the benefit of users who may not remember the order of the attributes, SQL allows the attributes to be specified as part of
the insert statement. For example, the following SQL insert statements are identical in
function to the preceding one:

        insert into course (course id, title, dept name, credits)
        values ('CS-437', 'Database Systems', 'Comp. Sci.', 4);
        
        insert into course (title, course id, credits, dept name)
        values ('Database Systems', 'CS-437', 4, 'Comp. Sci.');


More generally, we might want to insert tuples on the basis of the result of a query.
Suppose that we want to make each student in the Music department who has earned
more than 144 credit hours an instructor in the Music department with a salary of
$18,000. We write:

            insert into instructor
            select ID, name, dept name, 18000
            from student
            where dept name = 'Music' and tot cred > 144;

Instead of specifying a tuple as we did earlier in this section, we use a select to specify a
set of tuples. 

SQL evaluates the select statement first, giving a set of tuples that is then
inserted into the instructor relation. Each tuple has an ID, a name, a dept name (Music),
and a salary of $18,000.

It is important that the system evaluate the select statement fully before it performs
any insertions. If it were to carry out some insertions while the select statement was
being evaluated, a request such as:

            insert into student
            select *
            from student;

might insert an infinite number of tuples, if the primary key constraint on student were
absent. 
Without the primary key constraint, the request would insert the first tuple in
student again, creating a second copy of the tuple. Since this second copy is part of
student now, the select statement may find it, and a third copy would be inserted into
student. The select statement may then find this third copy and insert a fourth copy, and
so on, forever. Evaluating the select statement completely before performing insertions
avoids such problems. 
Thus, the above insert statement would simply duplicate every
tuple in the student relation if the relation did not have a primary key constraint.


Our discussion of the insert statement considered only examples in which a value
is given for every attribute in inserted tuples. 
It is possible for inserted tuples to be given
values on only some attributes of the schema. The remaining attributes are assigned a
null value denoted by null. Consider the request:
              
              insert into student
              values ('3003', 'Green', 'Finance', null);

The tuple inserted by this request specified that a student with ID “3003” is in the
Finance department, but the tot cred value for this student is not known.

Most relational database products have special “bulk loader” utilities to insert a
large set of tuples into a relation. These utilities allow data to be read from formatted text files, and they can execute much faster than an equivalent sequence of insert
statements.


                  Updates
In certain situations, we may wish to change a value in a tuple without changing all
values in the tuple. 
For this purpose, the update statement can be used. As we could
for insert and delete, we can choose the tuples to be updated by using a query.

Suppose that annual salary increases are being made, and salaries of all instructors
are to be increased by 5 percent. We write:

                  update instructor
                  set salary= salary * 1.05;

The preceding update statement is applied once to each of the tuples in the instructor
relation.

If a salary increase is to be paid only to instructors with a salary of less than
$70,000, we can write:

                update instructor
                set salary = salary * 1.05
                where salary < 70000;

In general, the where clause of the update statement may contain any construct legal
in the where clause of the select statement (including nested selects). 

As with insert and delete, a nested select within an update statement may reference the relation that
is being updated. As before, SQL first tests all tuples in the relation to see whether
they should be updated, and it carries out the updates afterward. 

For example, we can
write the request “Give a 5 percent salary raise to instructors whose salary is less than
average” as follows:
                
                update instructor
                set salary = salary * 1.05
                where salary < (select avg (salary)
                from instructor);


Let us now suppose that all instructors with salary over $100,000 receive a 3 percent raise, whereas all others receive a 5 percent raise. We could write two update
statements:

            update instructor
            set salary = salary * 1.03
            where salary > 100000;

            update instructor
            set salary = salary * 1.05
            where salary <= 100000;

Note that the order of the two update statements is important. If we changed the order
of the two statements, an instructor with a salary just under $100,000 would receive a
raise of over 8 percent.

SQL provides a case construct that we can use to perform both updates with a
single update statement, avoiding the problem with the order of updates.

update instructor
set salary = case
                when salary <= 100000 then salary * 1.05
                else salary * 1.03
              end


The general form of the case statement is as follows:
case
          when pred1 then result1
          when pred2 then result2
          …
          when predn then resultn
          else result0
end

The operation returns resulti... where i is the first of pred1, pred2, ..., predn that is satisfied; if none of the predicates is satisfied, the operation returns result0. Case statements
can be used in any place where a value is expected.


Scalar subqueries are useful in SQL update statements, where they can be used in
the set clause. We illustrate this using the student and takes relations that we introduced
in Chapter 2. 

Consider an update where we set the tot cred attribute of each student
tuple to the sum of the credits of courses successfully completed by the student. 

We assume that a course is successfully completed if the student has a grade that is neither
'F' nor null. To specify this update, we need to use a subquery in the set clause, as
shown below:

          update student
          set tot cred = (
          select sum(credits)
          from takes, course
          where student.ID= takes.ID and
          takes.course id = course.course id and
          takes.grade <> 'F' and
          takes.grade is not null);

In case a student has not successfully completed any course, the preceding statement
would set the tot cred attribute value to null. 
To set the value to 0 instead, we could
use another update statement to replace null values with 0; a better alternative is to
replace the clause “select sum(credits)” in the preceding subquery with the following
select clause using a case expression:

        select case
              when sum(credits) is not null then sum(credits)
              else 0
              end

Many systems support a coalesce function, which we describe in more detail later,
in Section 4.5.2, which provides a concise way of replacing nulls by other values. In
the above example, we could have used coalesce(sum(credits), 0) instead of the case
expression; this expression would return the aggregate result sum(credits) if it is not
null, and 0 otherwise.






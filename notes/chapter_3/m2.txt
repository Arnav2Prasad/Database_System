                    Aggregate Functions

Aggregate functions are functions that take a collection (a set or multiset) of values as
input and return a single value. SQL offers five standard built-in aggregate functions:9
            • Average: avg
            • Minimum: min
            • Maximum: max
            • Total: sum
            • Count: count
The input to sum and avg must be a collection of numbers, but the other operators can
operate on collections of nonnumeric data types, such as strings, as well.

                Basic Aggregation
Consider the query 
“Find the average salary of instructors in the Computer Science department.” 
We write this query as follows:
        select avg (salary)
        from instructor
        where dept name = 'Comp. Sci.';
The result of this query is a relation with a single attribute containing a single tuple with
a numerical value corresponding to the average salary of instructors in the Computer
Science department. 

The database system may give an awkward name to the result
relation attribute that is generated by aggregation, consisting of the text of the expression; 
however, we can give a meaningful name to the attribute by using the as clause as
follows:
          select avg (salary) as avg salary
          from instructor
          where dept name = 'Comp. Sci.';

In the instructor relation of Figure 2.1, the salaries in the Computer Science department 
are $75,000, $65,000, and $92,000. The average salary is $232,000∕3 =
$77,333.33.

Retaining duplicates is important in computing an average. Suppose the Computer
Science department adds a fourth instructor whose salary happens to be $75,000. 
If duplicates were eliminated, we would obtain the wrong answer ($232,000∕4 = $58,000)
rather than the correct answer of $76,750.

There are cases where we must eliminate duplicates before computing an aggregate function. 
If we do want to eliminate duplicates, we use the keyword distinct in the
aggregate expression. 
An example arises in the query “Find the total number of instructors who teach a course in the Spring 2018 semester.” 
In this case, an instructor counts
only once, regardless of the number of course sections that the instructor teaches. The
required information is contained in the relation teaches, and we write this query as
follows:
              select count (distinct ID)
              from teaches
              where semester = 'Spring' and year = 2018;

Because of the keyword distinct preceding ID, even if an instructor teaches more than
one course, she is counted only once in the result.

We use the aggregate function count frequently to count the number of tuples in a
relation. The notation for this function in SQL is count (*). Thus, to find the number
of tuples in the course relation, we write
              select count (*)
              from course;

SQL does not allow the use of distinct with count (*). 

It is legal to use distinct with
max and min, even though the result does not change. We can use the keyword all in
place of distinct to specify duplicate retention, but since all is the default, there is no
need to do so.


                 Aggregation with Grouping
There are circumstances where we would like to apply the aggregate function not only
to a single set of tuples, but also to a group of sets of tuples; we specify this in SQL
using the group by clause. The attribute or attributes given in the group by clause are
used to form groups. Tuples with the same value on all attributes in the group by clause
are placed in one group.

As an illustration, consider the query 
    “Find the average salary in each department.”
We write this query as follows:
          select dept name, avg (salary) as avg salary
          from instructor
          group by dept name;

Figure shows the tuples in the instructor relation grouped by the dept name
attribute, which is the first step in computing the query result. 
    The specified aggregate
is computed for each group, and the result of the query is shown in Figure.


In contrast, consider the query “Find the average salary of all instructors.” 
We write this query as follows:
          select avg (salary)
          from instructor;
In this case the group by clause has been omitted, so the entire relation is treated as a
single group.


As another example of aggregation on groups of tuples, consider the query 
“Find the number of instructors in each department who teach a course in the Spring 2018
semester.” 
Information about which instructors teach which course sections in which
semester is available in the teaches relation. However, this information has to be joined
with information from the instructor relation to get the department name of each instructor. 
Thus, we write this query as follows:
          select dept name, count (distinct ID) as instr count
          from instructor, teaches
          where instructor.ID= teaches.ID and
          semester = 'Spring' and year = 2018
          group by dept name;


When an SQL query uses grouping, it is important to ensure that the only attributes
that appear in the select statement without being aggregated are those that are present
in the group by clause. In other words, any attribute that is not present in the group by
clause may appear in the select clause only as an argument to an aggregate function,
otherwise the query is treated as erroneous. 
For example, the following query is erroneous since ID does not appear in the group by clause, and yet it appears in the select
clause without being aggregated:
          /* erroneous query */
          select dept name, ID, avg (salary)
          from instructor
          group by dept name;

In the preceding query, each instructor in a particular group (defined by dept name)
can have a different ID, and since only one tuple is output for each group, there is no
unique way of choosing which ID value to output. As a result, such cases are disallowed
by SQL.
The preceding query also illustrates a comment written in SQL by enclosing text
in “/* */”; the same comment could have also been written as “–– erroneous query”.


                The Having Clause
At times, it is useful to state a condition that applies to groups rather than to tuples. 

For example, we might be interested in only those departments where the average salary of
the instructors is more than $42,000. 
            This condition does not apply to a single tuple;
rather, it applies to each group constructed by the group by clause. To express such
a query, we use the having clause of SQL. SQL applies predicates in the having clause
after groups have been formed, so aggregate functions may be used in the having clause.
We express this query in SQL as follows:
          select dept name, avg (salary) as avg salary
          from instructor
          group by dept name
          having avg (salary) > 42000;

As was the case for the select clause, any attribute that is present in the having
clause without being aggregated must appear in the group by clause, otherwise the
query is erroneous.
The meaning of a query containing aggregation, group by, or having clauses is defined by the following sequence of operations:

        1. As was the case for queries without aggregation, the from clause is first evaluated
        to get a relation.
        2. If a where clause is present, the predicate in the where clause is applied on the
        result relation of the from clause.
        3. Tuples satisfying the where predicate are then placed into groups by the group
        by clause if it is present. If the group by clause is absent, the entire set of tuples
        satisfying the where predicate is treated as being in one group.
        4. The having clause, if it is present, is applied to each group; the groups that do not
        satisfy the having clause predicate are removed.
        5. The select clause uses the remaining groups to generate tuples of the result of the
        query, applying the aggregate functions to get a single result tuple for each group.


To illustrate the use of both a having clause and a where clause in the same query,
we consider the query “For each course section offered in 2017, find the average total
credits (tot cred) of all students enrolled in the section, if the section has at least 2
students.”
            select course id, semester, year, sec id, avg (tot cred)
            from student, takes
            where student.ID= takes.ID and year = 2017
            group by course id, semester, year, sec id
            having count (ID) >= 2;
Note that all the required information for the preceding query is available from the
relations takes and student, and that although the query pertains to sections, a join
with section is not needed.


                      Aggregation with Null and Boolean Values
Null values, when they exist, complicate the processing of aggregate operators. 

For example, assume that some tuples in the instructor relation have a null value for salary.
Consider the following query to total all salary amounts:
    select sum (salary)
    from instructor;
The values to be summed in the preceding query include null values, since we assumed
that some tuples have a null value for salary. 
Rather than say that the overall sum is
itself null, 
            the SQL standard says that the sum operator should ignore null values in its input.


In general, aggregate functions treat nulls according to the following rule: 
          All aggregate functions except count (*) ignore null values in their input collection. 
          
As a result of null values being ignored, the collection of values may be empty. 
The count of an empty collection is defined to be 0, and all other aggregate operations return a value
of null when applied on an empty collection. The effect of null values on some of the
more complicated SQL constructs can be subtle.

A Boolean data type that can take values true, false, and unknown was introduced
in SQL:1999. 

The aggregate functions some and every can be applied on a collection of
Boolean values, and compute the disjunction (or) and conjunction (and), respectively,
of the values.



              Nested Subqueries
SQL provides a mechanism for nesting subqueries. A subquery is a select-from-where
expression that is nested within another query. A common use of subqueries is to perform tests for
set membership, make set comparisons, and determine set cardinality
by nesting subqueries in the where clause.


              Set Membership
SQL allows testing tuples for membership in a relation. The in connective tests for set
membership, where the set is a collection of values produced by a select clause. The
not in connective tests for the absence of set membership.

As an illustration, reconsider the query 
“Find all the courses taught in the both the Fall 2017 and Spring 2018 semesters.” 
Earlier, we wrote such a query by intersecting
two sets: 
  the set of courses taught in Fall 2017 and the set of courses taught in Spring
  2018. 

We can take the alternative approach of finding all courses that were taught in
Fall 2017 and that are also members of the set of courses taught in Spring 2018. 

This formulation generates the same results as the previous one did, but it leads us to write
our query using the in connective of SQL. We begin by finding all courses taught in
Spring 2018, and we write the subquery:
        (select course id
        from section  
        where semester = 'Spring' and year= 2018)
        
We then need to find those courses that were taught in the Fall 2017 and that appear
in the set of courses obtained in the subquery. 
We do so by nesting the subquery in the
where clause of an outer query. 
The resulting query is:
      select distinct course id
      from section
      where semester = 'Fall' and year= 2017 and
      course id in (select course id
      from section
      where semester = 'Spring' and year= 2018);


Note that we need to use distinct here because the intersect operation removes duplicates by default.
This example shows that it is possible to write the same query several ways in SQL.
This flexibility is beneficial, since it allows a user to think about the query in the way
that seems most natural. We shall see that there is a substantial amount of redundancy
in SQL.

We use the "not in" construct in a way similar to the in construct. 

For example, to find all the courses taught in the Fall 2017 semester but not in the Spring 2018 semester,
which we expressed earlier using the except operation, we can write:
          select distinct course id
          from section
          where semester = 'Fall' and year= 2017 and
          course id not in (select course id
          from section
          where semester = 'Spring' and year= 2018);
          
The "in" and "not in" operators can also be used on enumerated sets. The following
query selects the names of instructors whose names are neither “Mozart” nor “Einstein”.
          select distinct name
          from instructor
          where name not in ('Mozart', 'Einstein');

In the preceding examples, we tested membership in a one-attribute relation. 

It is also possible to test for membership in an arbitrary relation in SQL. 
For example, we can write the query 
    “find the total number of (distinct) students who have taken course sections taught by the instructor 
    with ID 110011” as follows:
    
      select count (distinct ID)
      from takes
      where (course id, sec id, semester, year) in (select course id, sec id, semester, year
      from teaches
      where teaches.ID= '10101');
Note, however, that some SQL implementations do not support the row construction syntax “(course id, sec id, semester, year)” used above. 
We will see alternative ways of writing this query.



            Set Comparison
As an example of the ability of a nested subquery to compare sets, consider the query
“Find the names of all instructors whose salary is greater than at least one instructor
in the Biology department.” In Section 3.4.1, we wrote this query as follows:

          select distinct T.name
          from instructor as T, instructor as S
          where T.salary > S.salary and S.dept name = 'Biology';
          
SQL does, however, offer an alternative style for writing the preceding query. The phrase
“greater than at least one” is represented in SQL by "> some". This construct allows us
to rewrite the query in a form that resembles closely our formulation of the query in
English.

          select name
          from instructor
          where salary > some (select salary
          from instructor
          where dept name = 'Biology');

The subquery:
      (select salary
      from instructor
      where dept name = 'Biology')
      
generates the set of all salary values of all instructors in the Biology department. The >
some comparison in the where clause of the outer select is true if the salary value of the
tuple is greater than at least one member of the set of all salary values for instructors
in Biology.

SQL also allows < some, <= some, >= some, = some, and <> some comparisons.
As an exercise, verify that = some is identical to in, whereas <> some is not the same
as not in.

Now we modify our query slightly. Let us find the names of all instructors that
have a salary value greater than that of each instructor in the Biology department. The
construct > all corresponds to the phrase “greater than all.” Using this construct, we
write the query as follows:
      select name
      from instructor
      where salary > all (select salary
              from instructor
              where dept name = 'Biology');

As it does forsome, SQL also allows < all, <= all, >= all, = all, and <> all comparisons.

As an exercise, verify that <> all is identical to not in, whereas = all is not the same as
in.

As another example of set comparisons, consider the query “Find the departments
that have the highest average salary.” We begin by writing a query to find all average
salaries, and then nest it as a subquery of a larger query that finds those departments
for which the average salary is greater than or equal to all average salaries:
          select dept name
          from instructor
          group by dept name
          having avg (salary) >= all (select avg (salary)
                              from instructor
                              group by dept name);



              Test for Empty Relations
SQL includes a feature for testing whether a subquery has any tuples in its result. 

The exists construct returns the value true if the argument subquery is nonempty. Using the
exists construct, we can write the query “Find all courses taught in both the Fall 2017
semester and in the Spring 2018 semester” in still another way:
          
          select course id
          from section as S
          where semester = 'Fall' and year= 2017 and
          exists (select *
              from section as T
              where semester = 'Spring' and year= 2018 and
              S.course id= T.course id);


The above query also illustrates a feature of SQL where a correlation name from
an outer query (S in the above query), can be used in a subquery in the where clause.
A subquery that uses a correlation name from an outer query is called a correlated
subquery.

In queries that contain subqueries, a scoping rule applies for correlation names.
In a subquery, according to the rule, it is legal to use only correlation names defined
in the subquery itself or in any query that contains the subquery. If a correlation name
is defined both locally in a subquery and globally in a containing query, the local definition applies. 
This rule is analogous to the usual scoping rules used for variables in
programming languages.


We can test for the nonexistence of tuples in a subquery by using the not exists
construct. We can use the not exists construct to simulate the set containment (that
is, superset) operation: We can write “relation A contains relation B” as “not exists (B
except A).” (Although it is not part of the current SQL standards, the contains operator was present 
in some early relational systems.) To illustrate the not exists operator,
consider the query 
    “Find all students who have taken all courses offered in the Biology department.” 
  
Using the except construct, we can write the query as follows:
          
          select S.ID, S.name
          from student as S
          where not exists ((select course id
                  from course
                  where dept name = 'Biology')
                  except
                  (select T.course id
                  from takes as T
                  where S.ID = T.ID));

Here, the subquery:
          (select course id
          from course
          where dept name = 'Biology')
finds the set of all courses offered in the Biology department. 

The subquery:
          (select T.course id
          from takes as T
          where S.ID = T.ID)

finds all the courses that student S.ID has taken. 
Thus, the outer select takes each student and tests whether the set of all courses that the student has taken contains the set
of all courses offered in the Biology department.

We saw in Section 3.8.1, an SQL query to 
  “find the total number of (distinct) students who have taken course sections taught by the instructor with ID 110011”. 
  
That query used a tuple constructor syntax that is not supported by some databases. An
alternative way to write the query, using the exists construct, is as follows:
            
            select count (distinct ID)
            from takes
            where exists (select course id, sec id, semester, year
                  from teaches
                  where teaches.ID= '10101'
                  and takes.course id = teaches.course id
                  and takes.sec id = teaches.sec id
                  and takes.semester = teaches.semester
                  and takes.year = teaches.year
                  );



          Test for the Absence of Duplicate Tuples


















